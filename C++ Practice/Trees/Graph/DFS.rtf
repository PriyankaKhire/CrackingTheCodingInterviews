{\rtf1\ansi\ansicpg1252\cocoartf1187\cocoasubrtf400
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red0\green116\blue0;\red170\green13\blue145;\red28\green0\blue207;
\red92\green38\blue153;\red63\green110\blue116;\red46\green13\blue110;\red38\green71\blue75;\red196\green26\blue22;
}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab529
\pard\tx529\pardeftab529\pardirnatural

\f0\fs22 \cf0 \CocoaLigature0 \
\cf2 //Depth First search\cf0 \
\cf2 /*\
 1) have a graph\
 2) have an array which has all the nodes of the graph we call this array the visited array\
 3) have a stack\
 4) have an output array\
 5) start with root of the graph and push it on stack mark it visited and put it in output\
 6) now go to top of stack and see the top node see if it has any adjacent nodes\
 7) if it has any adjacent nodes and they are not visited then visit them one by one push them on stack and see their unvisited adjacent nodes\
 8) when we see a node on top of the stack and that node has all the adjacent nodes visited then push it out of the stack\
 9) when stack becomes empty then algorithm stops\
 */\cf0 \
\
\cf3 const\cf0  \cf3 static\cf0  \cf3 int\cf0  N = \cf4 9\cf0 ;\
\cf5 stack\cf0 <\cf3 int\cf0 > stck;\
\cf3 int\cf0  output[\cf6 N\cf0 ];\
\cf3 int\cf0  visited[\cf6 N\cf0 ];\
\cf3 int\cf0  outputCount = \cf4 0\cf0 ;\
\cf3 bool\cf0  IsVisited(\cf3 int\cf0  j)\
\{\
    \cf3 if\cf0 (\cf6 visited\cf0 [j] == \cf4 1\cf0 )\
        \cf3 return\cf0  \cf3 true\cf0 ;\
    \cf3 else\cf0 \
        \cf3 return\cf0  \cf3 false\cf0 ;\
\}\
\
\cf3 void\cf0  DFS(\cf3 int\cf0  graph[N][\cf6 N\cf0 ])\
\{\
    \cf3 if\cf0 (!\cf6 stck\cf0 .\cf7 empty\cf0 ())\
    \{\
    \cf3 int\cf0  i = \cf6 stck\cf0 .\cf7 top\cf0 ();\
    \cf3 for\cf0 (\cf3 int\cf0  j = \cf4 0\cf0 ; j<\cf6 N\cf0 ; j++)\
    \{\
        \cf3 if\cf0 (graph[i][j] == \cf4 1\cf0  && \cf8 IsVisited\cf0 (j) == \cf3 false\cf0 )\
        \{\
            \cf2 //Edge between i and j\cf0 \
            \cf2 // j is not visited\cf0 \
            \cf6 visited\cf0 [j] = \cf4 1\cf0 ;\
            \cf6 output\cf0 [\cf6 outputCount\cf0 ] = j;\
            \cf6 outputCount\cf0 ++;\
            \cf6 stck\cf0 .\cf7 push\cf0 (j);\
            \cf8 DFS\cf0 (graph);\
        \}\
        \
    \}\
    \cf6 stck\cf0 .\cf7 pop\cf0 ();\
    \}\
    \cf3 else\cf0 \
    \{\
        \cf3 return\cf0 ;\
    \}\
\}\
\
\cf3 int\cf0  main()\
\{\
    \cf3 int\cf0  graph[N][\cf6 N\cf0 ];\
    \
    \cf5 cout\cf0 <<\cf9 "Enter nodes of graph\\n"\cf0 ;\
    \cf3 for\cf0 (\cf3 int\cf0  i = \cf4 0\cf0 ; i<\cf6 N\cf0 ; i++)\
    \{\
        \cf3 for\cf0  (\cf3 int\cf0  j = \cf4 0\cf0 ; j < \cf6 N\cf0 ; j++)\
        \{\
            \cf5 cin\cf0 >>graph[i][j];\
        \}\
    \}\
    \
    \cf6 visited\cf0 [\cf4 0\cf0 ] = \cf4 1\cf0 ;\
    \cf6 output\cf0 [\cf6 outputCount\cf0 ] = \cf4 0\cf0 ;\
    \cf6 outputCount\cf0 ++;\
    \cf6 stck\cf0 .\cf7 push\cf0 (\cf4 0\cf0 );\
    \cf8 DFS\cf0 (graph);\
    \
    \
    \
    \
    \cf5 cout\cf0 <<\cf9 "The graph is\\n"\cf0 ;\
    \cf3 for\cf0 (\cf3 int\cf0  i = \cf4 0\cf0 ; i <\cf6 N\cf0 ; i++)\
    \{\
        \cf3 for\cf0 (\cf3 int\cf0  j = \cf4 0\cf0 ; j < \cf6 N\cf0 ; j++)\
        \{\
            \cf5 cout\cf0 <<graph[i][j]<<\cf9 " "\cf0 ;\
        \}\
        \cf5 cout\cf0 <<\cf7 endl\cf0 ;\
    \}\
    \
    \
    \cf3 for\cf0 (\cf3 int\cf0  i = \cf4 0\cf0 ; i <\cf6 N\cf0  ; i++)\
    \{\
        \cf5 cout\cf0 <<\cf6 output\cf0 [i]<<\cf9 " "\cf0 ;\
    \}\
\}\
\
\cf2 /*\
 \
 input:\
 0 1 0 0 0 0 0 0 1\
 1 0 0 0 0 0 0 0 0\
 0 0 0 1 1 1 0 0 1\
 0 0 1 0 0 0 0 0 0\
 0 0 1 0 0 0 0 1 0\
 0 0 1 0 0 0 1 0 0\
 0 0 0 0 0 1 0 1 1\
 0 0 0 0 1 0 1 0 0\
 1 0 1 0 0 0 1 0 0\
 \
 output:\
 0 1 8 2 3 4 7 6 5\
 \
 */\
\
==================================================================================================================================================================\
\
\
\cf0 \
\cf2 //A B C D E F G H S\cf0 \
\cf2 //0 1 2 3 4 5 6 7 8\cf0 \
\cf3 int\cf0  matrix[\cf4 9\cf0 ][\cf4 9\cf0 ] = \{\{\cf4 0\cf0 , \cf4 1\cf0 , \cf4 0\cf0 , \cf4 0\cf0 , \cf4 0\cf0 , \cf4 0\cf0 , \cf4 0\cf0 , \cf4 0\cf0 , \cf4 1\cf0 \},\
    \{\cf4 1\cf0 , \cf4 0\cf0 , \cf4 0\cf0 , \cf4 0\cf0 , \cf4 0\cf0 , \cf4 0\cf0 , \cf4 0\cf0 , \cf4 0\cf0 , \cf4 0\cf0 \},\
    \{\cf4 0\cf0 , \cf4 0\cf0 , \cf4 0\cf0 , \cf4 1\cf0 , \cf4 1\cf0 , \cf4 1\cf0 , \cf4 0\cf0 , \cf4 0\cf0 , \cf4 1\cf0 \},\
    \{\cf4 0\cf0 , \cf4 0\cf0 , \cf4 1\cf0 , \cf4 0\cf0 , \cf4 0\cf0 , \cf4 0\cf0 , \cf4 0\cf0 , \cf4 0\cf0 , \cf4 0\cf0 \},\
    \{\cf4 0\cf0 , \cf4 0\cf0 , \cf4 1\cf0 , \cf4 0\cf0 , \cf4 0\cf0 , \cf4 0\cf0 , \cf4 0\cf0 , \cf4 1\cf0 , \cf4 0\cf0 \},\
    \{\cf4 0\cf0 , \cf4 0\cf0 , \cf4 1\cf0 , \cf4 0\cf0 , \cf4 0\cf0 , \cf4 0\cf0 , \cf4 1\cf0 , \cf4 0\cf0 , \cf4 0\cf0 \},\
    \{\cf4 0\cf0 , \cf4 0\cf0 , \cf4 0\cf0 , \cf4 0\cf0 , \cf4 0\cf0 , \cf4 1\cf0 , \cf4 0\cf0 , \cf4 0\cf0 , \cf4 1\cf0 \},\
    \{\cf4 0\cf0 , \cf4 0\cf0 , \cf4 0\cf0 , \cf4 0\cf0 , \cf4 1\cf0 , \cf4 0\cf0 , \cf4 1\cf0 , \cf4 0\cf0 , \cf4 0\cf0 \},\
    \{\cf4 0\cf0 , \cf4 0\cf0 , \cf4 1\cf0 , \cf4 0\cf0 , \cf4 0\cf0 , \cf4 0\cf0 , \cf4 1\cf0 , \cf4 0\cf0 , \cf4 0\cf0 \}\
\};\
\cf3 int\cf0  visited[\cf4 9\cf0 ];\
\
\cf5 stack\cf0 <\cf3 int\cf0 >DFSstack;\
\
\cf3 void\cf0  DFS()\
\{\
    \cf3 if\cf0 (!\cf6 DFSstack\cf0 .\cf7 empty\cf0 ())\
    \{\
        \cf3 int\cf0  top = \cf6 DFSstack\cf0 .\cf7 top\cf0 ();\
        \cf6 DFSstack\cf0 .\cf7 pop\cf0 ();\
        \cf3 for\cf0 (\cf3 int\cf0  i = \cf4 0\cf0 ; i < \cf4 9\cf0 ; i++)\
        \{\
            \cf3 if\cf0 (\cf6 matrix\cf0 [top][i] == \cf4 1\cf0  && \cf6 visited\cf0 [i] == \cf4 0\cf0 )\
            \{\
                \cf6 visited\cf0 [i] = \cf4 1\cf0 ;\
                \cf5 cout\cf0 <<i<<\cf9 " "\cf0 ;\
                \cf6 DFSstack\cf0 .\cf7 push\cf0 (i);\
                \cf8 DFS\cf0 ();\
            \}\
        \}\
    \}\
\}\
\
\cf3 int\cf0  main()\
\{\
    \cf2 //Initialise visited\cf0 \
    \cf3 for\cf0 (\cf3 int\cf0  i = \cf4 0\cf0  ; i < \cf4 9\cf0 ; i ++)\
    \{\
        \cf6 visited\cf0 [i] = \cf4 0\cf0 ;\
    \}\
    \
    \cf2 //Push root which is A at index 0\cf0 \
    \cf6 DFSstack\cf0 .\cf7 push\cf0 (\cf4 0\cf0 );\
    \cf6 visited\cf0 [\cf4 0\cf0 ] = \cf4 1\cf0 ;\
    \cf5 cout\cf0 <<\cf4 0\cf0 <<\cf9 " "\cf0 ;\
    \cf8 DFS\cf0 ();\
    \
    \cf2 //A B S C D E H G F\cf0 \
    \
    \
    \
\}\
}