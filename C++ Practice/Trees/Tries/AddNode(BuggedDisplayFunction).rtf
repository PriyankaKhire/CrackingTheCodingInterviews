{\rtf1\ansi\ansicpg1252\cocoartf1187\cocoasubrtf400
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red170\green13\blue145;\red63\green110\blue116;\red28\green0\blue207;
\red92\green38\blue153;\red196\green26\blue22;\red46\green13\blue110;\red38\green71\blue75;\red0\green116\blue0;
}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab529
\pard\tx529\pardeftab529\pardirnatural

\f0\fs22 \cf2 \CocoaLigature0 struct\cf0  Tries\
\{\
    \cf2 int\cf0  word;\
    \cf2 int\cf0  prefix;\
    \cf3 Tries\cf0  *edges[\cf4 26\cf0 ];\
\};\
\
\cf3 Tries\cf0  *Root = \cf2 new\cf0  \cf3 Tries\cf0 ;\
\
\cf3 Tries\cf0  *createEdge()\
\{\
    \cf3 Tries\cf0  *Edge;\
    Edge = \cf2 new\cf0  \cf3 Tries\cf0 ;\
    \
    \cf2 return\cf0  Edge;\
\}\
\
\cf2 void\cf0  initialize(\cf3 Tries\cf0  *vertex)\
\{\
    vertex->\cf3 word\cf0  = \cf4 0\cf0 ;\
    vertex->\cf3 prefix\cf0  = \cf4 0\cf0 ;\
    \cf2 for\cf0 (\cf2 int\cf0  i = \cf4 0\cf0 ; i <\cf4 26\cf0 ; i++)\
    \{\
        vertex->\cf3 edges\cf0 [i] = \cf2 NULL\cf0 ;\
    \}\
\}\
\
\cf2 void\cf0  addWord(\cf3 Tries\cf0  *vertex, \cf5 string\cf0  word)\
\{\
    \cf2 if\cf0 (word == \cf6 ""\cf0 )\
    \{\
        \cf5 cout\cf0 <<vertex<<\cf6 " Empty\\n"\cf0 ;\
        vertex->\cf3 word\cf0  = vertex->\cf3 word\cf0  + \cf4 1\cf0 ;\
        \cf2 return\cf0 ;\
    \}\
    \cf2 else\cf0 \
    \{\
        \cf2 char\cf0  k = \cf7 tolower\cf0 (word[\cf4 0\cf0 ]);\
        \cf2 int\cf0  index = \cf2 int\cf0 (k) - \cf2 int\cf0  (\cf4 'a'\cf0 );\
        \cf5 cout\cf0 <<word;\
        \cf2 if\cf0 (vertex->\cf3 edges\cf0 [index] == \cf2 NULL\cf0 )\
        \{\
            \cf5 cout\cf0 <<\cf6 " here for "\cf0 <<k<<\cf6 " "\cf0 <<vertex<<\cf7 endl\cf0 ;\
            \cf3 Tries\cf0  *edgesK = \cf8 createEdge\cf0 ();\
            \cf8 initialize\cf0 (edgesK);\
            vertex->\cf3 edges\cf0 [index] = edgesK;\
        \}\
        vertex->\cf3 prefix\cf0  = vertex->\cf3 prefix\cf0  + \cf4 1\cf0 ;\
        word = word.\cf7 erase\cf0 (\cf4 0\cf0 , \cf4 1\cf0 );\
        \cf8 addWord\cf0 (vertex->\cf3 edges\cf0 [index], word);\
    \}\
\}\
\
\cf2 char\cf0  dictionary(\cf2 int\cf0  number)\
\{\
    \cf2 switch\cf0 (number)\
    \{\
        \cf2 case\cf0  \cf4 0\cf0 : \cf2 return\cf0  \cf4 'a'\cf0 ;\
            \cf2 break\cf0 ;\
        \cf2 case\cf0  \cf4 1\cf0 : \cf2 return\cf0  \cf4 'b'\cf0 ;\
            \cf2 break\cf0 ;\
        \cf2 case\cf0  \cf4 2\cf0 : \cf2 return\cf0  \cf4 'c'\cf0 ;\
            \cf2 break\cf0 ;\
        \cf2 case\cf0  \cf4 3\cf0 : \cf2 return\cf0  \cf4 'd'\cf0 ;\
            \cf2 break\cf0 ;\
        \cf2 case\cf0  \cf4 4\cf0 : \cf2 return\cf0  \cf4 'e'\cf0 ;\
            \cf2 break\cf0 ;\
        \cf2 case\cf0  \cf4 5\cf0 : \cf2 return\cf0  \cf4 'f'\cf0 ;\
            \cf2 break\cf0 ;\
        \cf2 case\cf0  \cf4 6\cf0 : \cf2 return\cf0  \cf4 'g'\cf0 ;\
            \cf2 break\cf0 ;\
        \cf2 case\cf0  \cf4 7\cf0 : \cf2 return\cf0  \cf4 'h'\cf0 ;\
            \cf2 break\cf0 ;\
        \cf2 case\cf0  \cf4 8\cf0 : \cf2 return\cf0  \cf4 'i'\cf0 ;\
            \cf2 break\cf0 ;\
        \cf2 case\cf0  \cf4 9\cf0 : \cf2 return\cf0  \cf4 'j'\cf0 ;\
            \cf2 break\cf0 ;\
        \cf2 case\cf0  \cf4 10\cf0 : \cf2 return\cf0  \cf4 'k'\cf0 ;\
            \cf2 break\cf0 ;\
        \cf2 case\cf0  \cf4 11\cf0 : \cf2 return\cf0  \cf4 'l'\cf0 ;\
            \cf2 break\cf0 ;\
        \cf2 case\cf0  \cf4 12\cf0 : \cf2 return\cf0  \cf4 'm'\cf0 ;\
            \cf2 break\cf0 ;\
        \cf2 case\cf0  \cf4 13\cf0 : \cf2 return\cf0  \cf4 'n'\cf0 ;\
            \cf2 break\cf0 ;\
        \cf2 case\cf0  \cf4 14\cf0 : \cf2 return\cf0  \cf4 'o'\cf0 ;\
            \cf2 break\cf0 ;\
        \cf2 case\cf0  \cf4 15\cf0 : \cf2 return\cf0  \cf4 'p'\cf0 ;\
            \cf2 break\cf0 ;\
        \cf2 case\cf0  \cf4 16\cf0 : \cf2 return\cf0  \cf4 'q'\cf0 ;\
            \cf2 break\cf0 ;\
        \cf2 case\cf0  \cf4 17\cf0 : \cf2 return\cf0  \cf4 'r'\cf0 ;\
            \cf2 break\cf0 ;\
        \cf2 case\cf0  \cf4 18\cf0 : \cf2 return\cf0  \cf4 's'\cf0 ;\
            \cf2 break\cf0 ;\
        \cf2 case\cf0  \cf4 19\cf0 : \cf2 return\cf0  \cf4 't'\cf0 ;\
            \cf2 break\cf0 ;\
        \cf2 case\cf0  \cf4 20\cf0 : \cf2 return\cf0  \cf4 'u'\cf0 ;\
            \cf2 break\cf0 ;\
        \cf2 case\cf0  \cf4 21\cf0 : \cf2 return\cf0  \cf4 'v'\cf0 ;\
            \cf2 break\cf0 ;\
        \cf2 case\cf0  \cf4 22\cf0 : \cf2 return\cf0  \cf4 'w'\cf0 ;\
            \cf2 break\cf0 ;\
        \cf2 case\cf0  \cf4 23\cf0 : \cf2 return\cf0  \cf4 'x'\cf0 ;\
            \cf2 break\cf0 ;\
        \cf2 case\cf0  \cf4 24\cf0 : \cf2 return\cf0  \cf4 'y'\cf0 ;\
            \cf2 break\cf0 ;\
        \cf2 case\cf0  \cf4 25\cf0 : \cf2 return\cf0  \cf4 'z'\cf0 ;\
            \cf2 break\cf0 ;\
        \cf2 default\cf0 : \cf2 return\cf0  \cf4 '*'\cf0 ;\
            \cf2 break\cf0 ;\
    \}\
\}\
\
\cf2 void\cf0  display(\cf3 Tries\cf0  *node)\
\{\
    \cf2 if\cf0 (node != \cf2 NULL\cf0 )\
    \{\
        \cf2 for\cf0 (\cf2 int\cf0  i = \cf4 0\cf0 ; i < \cf4 26\cf0 ; i++)\
        \{\
            \cf2 if\cf0 (node->\cf3 edges\cf0 [i] != \cf2 NULL\cf0 )\
            \{\
                \cf2 char\cf0  k = \cf8 dictionary\cf0 (i);\
                \cf5 cout\cf0 <<k<<\cf6 " "\cf0 <<node->\cf3 word\cf0 <<\cf6 " "\cf0 <<i<<\cf6 " "\cf0 <<node<<\cf7 endl\cf0 ;\
                \cf2 if\cf0 (node->\cf3 word\cf0  == \cf4 0\cf0 )\
                \{\
                    node = node->\cf3 edges\cf0 [i];\
                    \cf8 display\cf0 (node);\
                    \cf5 cout\cf0 <<\cf6 "*"\cf0 ;\
                \}\
                \cf2 else\cf0 \
                \{\
                    \cf2 return\cf0 ;\
                \}\
            \}\
        \}\
    \}\
\}\
\
\cf2 int\cf0  main()\
\{\
    \cf8 initialize\cf0 (\cf3 Root\cf0 );\
    \
    \cf9 //Adding a dummy Word = "word" to check the working\cf0 \
    \cf9 // w\cf0 \
    \cf5 string\cf0  word = \cf6 "word"\cf0 ;\
    \cf3 Tries\cf0  *RootPointer;\
    RootPointer = \cf3 Root\cf0 ;\
    \
    \cf2 while\cf0 (word != \cf6 ""\cf0 )\
    \{\
        \cf5 cout\cf0 <<word;\
        \cf2 char\cf0  k = \cf7 tolower\cf0 (word[\cf4 0\cf0 ]);\
        word = word.\cf7 erase\cf0 (\cf4 0\cf0 ,\cf4 1\cf0 );\
        \cf2 int\cf0  index = \cf2 int\cf0 (k) - \cf2 int\cf0 (\cf4 'a'\cf0 );\
        \cf2 if\cf0 (RootPointer->\cf3 edges\cf0 [index] == \cf2 NULL\cf0 )\
        \{\
            \cf3 Tries\cf0  *edgesK = \cf8 createEdge\cf0 ();\
            \cf8 initialize\cf0 (edgesK);\
            RootPointer->\cf3 edges\cf0 [index] = edgesK;\
            edgesK->\cf3 prefix\cf0  = edgesK->\cf3 prefix\cf0  + \cf4 1\cf0 ;\
        \}\
        \cf5 cout\cf0 <<\cf6 " "\cf0 <<word<<\cf7 endl\cf0 ;\
        \cf2 if\cf0 (word == \cf6 ""\cf0 )\
        \{\
            \cf5 cout\cf0 <<\cf6 "test"\cf0 ;\
            RootPointer->\cf3 word\cf0  = RootPointer->\cf3 word\cf0  + \cf4 1\cf0 ;\
        \}\
        \cf2 else\cf0 \
        \{\
            RootPointer = RootPointer->\cf3 edges\cf0 [index];\
        \}\
    \}\
    \
    \cf5 cout\cf0 <<\cf6 "\\n---------------"\cf0 <<\cf7 endl\cf0 ;\
    \cf8 addWord\cf0 (\cf3 Root\cf0 , \cf6 "wabc"\cf0 );\
    \cf9 //display(Root);\cf0 \
\}}