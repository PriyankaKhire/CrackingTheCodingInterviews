{\rtf1\ansi\ansicpg1252\cocoartf1187\cocoasubrtf400
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red170\green13\blue145;\red28\green0\blue207;\red92\green38\blue153;
\red196\green26\blue22;\red46\green13\blue110;\red0\green116\blue0;\red38\green71\blue75;\red63\green110\blue116;
}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab529
\pard\tx529\pardeftab529\pardirnatural

\f0\fs22 \cf0 \CocoaLigature0 \
\cf2 static\cf0  \cf2 const\cf0  \cf2 int\cf0  size = \cf3 7\cf0 ;\
\
\cf2 void\cf0  BinarySearch(\cf2 int\cf0  a[], \cf2 int\cf0  low, \cf2 int\cf0  high, \cf2 int\cf0  element)\
\{\
    \cf2 if\cf0 (low <= high)\
    \{\
        \cf2 int\cf0  mid = (low+high)/\cf3 2\cf0 ;\
        \cf2 if\cf0 (a[mid] == element)\
        \{\
            \cf4 cout\cf0 <<\cf5 "Found at position "\cf0 <<mid<<\cf6 endl\cf0 ;\
            \cf2 return\cf0 ;\
        \}\
        \cf2 else\cf0 \
        \{\
            \cf2 if\cf0 (element < a[mid])\
            \{\
                \cf7 //Move left\cf0 \
                \cf4 cout\cf0 <<\cf5 "Going Left\\n"\cf0 ;\
                \cf8 BinarySearch\cf0 (a, low, mid-\cf3 1\cf0 , element);\
            \}\
            \cf2 else\cf0 \
                \cf2 if\cf0 (element > a[mid])\
                \{\
                    \cf7 //Move Right\cf0 \
                    \cf4 cout\cf0 <<\cf5 "Going right\\n"\cf0 ;\
                    \cf8 BinarySearch\cf0 (a, mid+\cf3 1\cf0 , high, element);\
                \}\
        \}\
    \}\
\}\
\
\cf2 int\cf0  PivotPosition(\cf2 int\cf0  a[], \cf2 int\cf0  low, \cf2 int\cf0  high)\
\{\
    \cf2 if\cf0 (low <= high)\
    \{\
        \cf2 int\cf0  mid = (low+high)/\cf3 2\cf0 ;\
        \cf4 cout\cf0 <<\cf5 "Low = "\cf0 <<low<<\cf5 " high = "\cf0 <<high<<\cf5 " mid = "\cf0 <<mid<<\cf6 endl\cf0 ;\
        \
        \cf7 //If Pivot is located in the middle of the array\cf0 \
        \
        \cf7 //In order to check these 3 cases we need minimum of 3 elements between low and high\cf0 \
        \
        \cf2 if\cf0 (low < mid < high)\
        \{\
            \cf4 cout\cf0 <<\cf5 "low < mid < high\\n"\cf0 ;\
            \cf7 //Case 1 Pivot to right of mid\cf0 \
            \cf2 if\cf0 (a[mid] < a[mid+\cf3 1\cf0 ] && a[mid+\cf3 1\cf0 ] > a[mid+\cf3 2\cf0 ])\
            \{\
                \cf4 cout\cf0 <<\cf5 "Return mid+1\\n"\cf0 ;\
                \cf2 return\cf0  mid+\cf3 1\cf0 ;\
            \}\
            \cf7 //Case 2 Pivot to the left of mid\cf0 \
            \cf2 if\cf0 (a[mid] < a[mid-\cf3 1\cf0 ] && a[mid-\cf3 2\cf0 ] < a[mid-\cf3 1\cf0 ] )\
            \{\
                \cf4 cout\cf0 <<\cf5 "Return mid-1\\n"\cf0 ;\
                \cf2 return\cf0  mid-\cf3 1\cf0 ;\
            \}\
            \cf7 //Case 3 Pivot is mid\cf0 \
            \cf2 if\cf0 (a[mid] > a[mid+\cf3 1\cf0 ] && a[mid] > a[mid-\cf3 1\cf0 ])\
            \{\
                \cf4 cout\cf0 <<\cf5 "Return mid\\n"\cf0 ;\
                \cf2 return\cf0  mid;\
            \}\
            \cf7 //What if you land nowhere near the pivot ?\cf0 \
            \cf7 //The answer is in extremes\cf0 \
            \
            \cf7 //Case 1 pivot is towards left\cf0 \
            \cf2 if\cf0 (a[mid] < a[\cf3 0\cf0 ] && a[mid] < a[\cf9 size\cf0 -\cf3 1\cf0 ])\
            \{\
                \cf4 cout\cf0 <<\cf5 "Going left \\n"\cf0 ;\
                \cf2 return\cf0  \cf8 PivotPosition\cf0 (a, low, mid-\cf3 1\cf0 );\
            \}\
            \cf7 //Case 2 pivot is towards right\cf0 \
            \cf2 if\cf0 (a[mid] > a[\cf3 0\cf0 ] && a[mid] > a[\cf9 size\cf0 -\cf3 1\cf0 ])\
            \{\
                \cf4 cout\cf0 <<\cf5 "Going right\\n"\cf0 ;\
                \cf2 return\cf0  \cf8 PivotPosition\cf0 (a, mid+\cf3 1\cf0 , high);\
            \}\
            \
            \cf7 //Case 3 if array is already sorted\cf0 \
            \cf2 if\cf0 (a[\cf3 0\cf0 ] < a[mid] && a[mid] < a[\cf9 size\cf0 -\cf3 1\cf0 ])\
            \{\
                \cf7 //Then the array is already sorted we can perform normal binary search\cf0 \
                \cf4 cout\cf0 <<\cf5 "Array is already sorted so return nothing\\n"\cf0 ;\
                \cf2 return\cf0  -\cf3 999\cf0 ;\
            \}\
            \
        \}\
        \
        \cf7 //If Pivot is located at the edges\cf0 \
        \cf2 if\cf0 (low == high)\
        \{\
            \cf7 //If it is at 0th index\cf0 \
            \cf2 if\cf0 (low == \cf3 0\cf0 )\
            \{\
                \cf2 if\cf0 (a[low] > a[low+\cf3 1\cf0 ] && a[low] > a[\cf9 size\cf0 -\cf3 1\cf0 ])\
                \{\
                    \cf4 cout\cf0 <<\cf5 "Return low\\n"\cf0 ;\
                    \cf2 return\cf0  low;\
                \}\
            \}\
            \cf7 //If it is at size -1 index\cf0 \
            \cf2 if\cf0 (low == \cf9 size\cf0 -\cf3 1\cf0 )\
            \{\
                \cf7 //Then the array is already sorted we can perform normal binary search\cf0 \
                \cf4 cout\cf0 <<\cf5 "Array is already sorted so return nothing\\n"\cf0 ;\
                \cf2 return\cf0  -\cf3 999\cf0 ;\
            \}\
        \}\
        \
    \}\
    \cf2 return\cf0  -\cf3 1\cf0 ;\
\}\
\
\cf2 void\cf0  RotatedBinarySearch(\cf2 int\cf0  a[], \cf2 int\cf0  high, \cf2 int\cf0  low, \cf2 int\cf0  element)\
\{\
    \cf2 int\cf0  mid = (low+high)/\cf3 2\cf0 ;\
    \cf2 if\cf0 (element == a[mid])\
    \{\
        \cf4 cout\cf0 <<\cf5 "Found at position "\cf0 <<mid<<\cf6 endl\cf0 ;\
        \cf2 return\cf0 ;\
    \}\
    \
    \cf2 int\cf0  Pivot = \cf8 PivotPosition\cf0 (a, low, high);\
    \
    \cf2 if\cf0 (a[Pivot] == element)\
    \{\
        \cf4 cout\cf0 <<\cf5 "Found at position "\cf0 <<Pivot<<\cf6 endl\cf0 ;\
        \cf2 return\cf0 ;\
    \}\
    \
    \cf2 if\cf0 (Pivot == -\cf3 999\cf0 )\
    \{\
        \cf4 cout\cf0 <<\cf5 "Array is already sorted\\n"\cf0 ;\
        \cf8 BinarySearch\cf0 (a, low, high, element);\
    \}\
    \cf2 if\cf0 (Pivot == -\cf3 1\cf0 )\
    \{\
        \cf4 cout\cf0 <<\cf5 "Error\\n"\cf0 ;\
        \cf2 return\cf0 ;\
    \}\
    \cf2 if\cf0 (Pivot == \cf3 0\cf0 )\
    \{\
        \cf8 BinarySearch\cf0 (a, \cf3 1\cf0 , high, element);\
    \}\
    \cf2 else\cf0 \
    \{\
        \cf7 //Which half does the element lie in ?\cf0 \
        \cf7 //Left half\cf0 \
        \cf2 if\cf0 (element >= a[low] && element < a[Pivot])\
        \{\
            \cf2 if\cf0 (element == a[low])\
            \{\
                \cf4 cout\cf0 <<\cf5 "Found at position "\cf0 <<low<<\cf6 endl\cf0 ;\
                \cf2 return\cf0 ;\
            \}\
            \cf2 else\cf0 \
            \{\
                \cf8 BinarySearch\cf0 (a, low+\cf3 1\cf0 , Pivot-\cf3 1\cf0 , element);\
            \}\
        \}\
        \cf7 //Right half\cf0 \
        \cf2 if\cf0 (element >= a[Pivot+\cf3 1\cf0 ] && element <= a[high])\
        \{\
            \cf2 if\cf0 (element == a[Pivot+\cf3 1\cf0 ])\
            \{\
                \cf4 cout\cf0 <<\cf5 "Found at position "\cf0 <<Pivot+\cf3 1\cf0 <<\cf6 endl\cf0 ;\
                \cf2 return\cf0 ;\
            \}\
            \cf2 if\cf0 (element == a[high])\
            \{\
                \cf4 cout\cf0 <<\cf5 "Found at position "\cf0 <<high<<\cf6 endl\cf0 ;\
                \cf2 return\cf0 ;\
            \}\
            \cf2 else\cf0 \
            \{\
                \cf8 BinarySearch\cf0 (a, Pivot+\cf3 2\cf0 , high-\cf3 1\cf0 , element);\
            \}\
        \}\
    \}\
\}\
\
\cf2 int\cf0  main()\
\{\
    \cf2 int\cf0  a[\cf9 size\cf0 ] = \{\cf3 1\cf0 ,\cf3 2\cf0 ,\cf3 3\cf0 ,\cf3 4\cf0 ,\cf3 5\cf0 ,\cf3 6\cf0 ,\cf3 7\cf0 \};\
    \cf7 //BinarySearch(a, 0, size-1, 3);\cf0 \
    \
    \cf2 int\cf0  r[\cf9 size\cf0 ] = \{\cf3 5\cf0 ,\cf3 6\cf0 ,\cf3 7\cf0 ,\cf3 1\cf0 ,\cf3 2\cf0 ,\cf3 3\cf0 ,\cf3 4\cf0 \};\
    \cf8 RotatedBinarySearch\cf0 (r, \cf9 size\cf0 -\cf3 1\cf0 , \cf3 0\cf0 , \cf3 1\cf0 );\
\}}