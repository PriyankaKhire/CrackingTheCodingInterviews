{\rtf1\ansi\ansicpg1252\cocoartf1187\cocoasubrtf400
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red170\green13\blue145;\red28\green0\blue207;\red0\green116\blue0;
\red38\green71\blue75;\red63\green110\blue116;\red92\green38\blue153;\red196\green26\blue22;\red46\green13\blue110;
}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab529
\pard\tx529\pardeftab529\pardirnatural

\f0\fs22 \cf2 \CocoaLigature0 void\cf0  quickSort(\cf2 int\cf0  arr[], \cf2 int\cf0  left, \cf2 int\cf0  right) \{\
    \cf2 int\cf0  i = left, j = right;\
    \cf2 int\cf0  tmp;\
    \cf2 int\cf0  pivot = arr[(left + right) / \cf3 2\cf0 ];\
    \
    \cf4 /* partition */\cf0 \
    \cf2 while\cf0  (i <= j) \{\
        \cf2 while\cf0  (arr[i] < pivot)\
            i++;\
        \cf2 while\cf0  (pivot < arr[j])\
            j--;\
        \cf2 if\cf0  (i <= j)\
        \{\
            tmp = arr[i];\
            arr[i] = arr[j];\
            arr[j] = tmp;\
            i++;\
            j--;\
        \}\
    \};\
    \
    \cf4 /* recursion */\cf0 \
    \cf2 if\cf0  (left < j)\
        \cf5 quickSort\cf0 (arr, left, j);\
    \cf2 if\cf0  (i < right)\
        \cf5 quickSort\cf0 (arr, i, right);\
\}\
\
\
\cf2 int\cf0  main()\
\{\
    \cf2 int\cf0  a[\cf6 size\cf0 ] = \{\cf3 10\cf0 , \cf3 9\cf0 , \cf3 8\cf0 , \cf3 7\cf0 , \cf3 6\cf0 , \cf3 5\cf0 , \cf3 4\cf0 , \cf3 3\cf0 , \cf3 2\cf0 , \cf3 1\cf0 \};\
    \cf5 quickSort\cf0 (a, \cf3 0\cf0 , \cf3 9\cf0 );\
    \cf2 for\cf0 (\cf2 int\cf0  i = \cf3 0\cf0 ; i < \cf6 size\cf0 ; i ++)\
    \{\
        \cf7 cout\cf0 <<a[i]<<\cf8 " "\cf0 ;\
    \}\
    \
\}\
\
=================================================================================\
\
\
{\field{\*\fldinst{HYPERLINK "https://www.youtube.com/watch?v=aQiWF4E8flQ"}}{\fldrslt https://www.youtube.com/watch?v=aQiWF4E8flQ}}\
\
\cf2 const\cf0  \cf2 static\cf0  \cf2 int\cf0  size = \cf3 9\cf0 ;\
\
\cf2 void\cf0  QuickSort(\cf2 int\cf0  a[], \cf2 int\cf0  wall)\
\{\
    \cf4 //There has to be a stop condition to this recurssion\cf0 \
    \cf4 //Why size -1 coz current element is wall +1 so if wall is 8 and size is 9 then current element would go out of range and have some garbage value\cf0 \
    \cf2 if\cf0 (wall < \cf6 size\cf0 -\cf3 1\cf0 )\
    \{\
        \cf2 for\cf0 (\cf2 int\cf0  i = \cf3 0\cf0 ; i < \cf6 size\cf0 ; i++)\
        \{\
            \cf7 cout\cf0 <<a[i]<<\cf8 " "\cf0 ;\
        \}\
        \cf7 cout\cf0 <<\cf9 endl\cf0 ;\
        \
        \cf2 int\cf0  Pivot = \cf6 size\cf0 -\cf3 1\cf0 ;\
        \cf4 //Initially the current element is the first element to the right of the wall thus coz of this reason we have to start the wall from -1 and not zero. if we start from zero our current element will never consider array[0].\cf0 \
        \cf2 int\cf0  CurrentElement = wall+\cf3 1\cf0 ;\
        \
        \cf7 cout\cf0 <<\cf8 "Wall = "\cf0 <<wall<<\cf8 " current element = "\cf0 <<CurrentElement<<\cf8 " Pivot = "\cf0 <<Pivot<<\cf9 endl\cf0 ;\
        \
        \cf2 while\cf0 (CurrentElement < \cf6 size\cf0 )\
        \{\
            \cf2 if\cf0 (a[CurrentElement] < a[Pivot])\
            \{\
                \cf4 //Swap the current element with the lowest index sitting to the right of the wall\cf0 \
                \cf2 int\cf0  temp = a[CurrentElement];\
                a[CurrentElement] = a[wall+\cf3 1\cf0 ];\
                a[wall+\cf3 1\cf0 ] = temp;\
                wall++;\
            \}\
            CurrentElement++;\
        \}\
        \
        \cf4 //Make one last swap by dropping the pivot on immediate right of the wall\cf0 \
        \cf2 int\cf0  temp = a[Pivot];\
        a[Pivot] = a[wall+\cf3 1\cf0 ];\
        a[wall+\cf3 1\cf0 ] = temp;\
        wall++;\
        \cf2 for\cf0 (\cf2 int\cf0  i = \cf3 0\cf0 ; i < \cf6 size\cf0 ; i++)\
        \{\
            \cf7 cout\cf0 <<a[i]<<\cf8 " "\cf0 ;\
        \}\
        \cf7 cout\cf0 <<\cf9 endl\cf0 ;\
        \cf5 QuickSort\cf0 (a, wall);\
    \}\
\}\
\
\cf2 int\cf0  main()\
\{\
    \cf2 int\cf0  a[\cf6 size\cf0 ] = \{\cf3 6\cf0 ,\cf3 5\cf0 ,\cf3 1\cf0 ,\cf3 3\cf0 ,\cf3 8\cf0 ,\cf3 4\cf0 ,\cf3 7\cf0 ,\cf3 9\cf0 ,\cf3 2\cf0 \};\
    \cf5 QuickSort\cf0 (a, -\cf3 1\cf0 );\
\}\
\
=================================================================================\
\
\
\cf2 const\cf0  \cf2 static\cf0  \cf2 int\cf0  size = \cf3 8\cf0 ;\
\
\cf2 void\cf0  swap(\cf2 int\cf0  &a, \cf2 int\cf0  &b)\
\{\
    \cf2 int\cf0  temp = a;\
    a = b;\
    b = temp;\
\}\
\
\cf2 void\cf0  printArray(\cf2 int\cf0  a[])\
\{\
    \cf2 for\cf0 (\cf2 int\cf0  i = \cf3 0\cf0 ; i < \cf6 size\cf0 ; i++)\
    \{\
        \cf7 cout\cf0 <<a[i]<<\cf8 " "\cf0 ;\
    \}\
    \cf7 cout\cf0 <<\cf9 endl\cf0 ;\
\}\
\
\cf2 int\cf0  partition(\cf2 int\cf0  a[], \cf2 int\cf0  StartIndex, \cf2 int\cf0  EndIndex)\
\{\
    \cf2 if\cf0 (StartIndex <= EndIndex)\
    \{\
        \cf5 printArray\cf0 (a);\
        \cf2 int\cf0  PivotPosition = EndIndex;\
        \cf2 int\cf0  lessThanPivot = StartIndex;\
        \cf2 int\cf0  greaterThanPivot = EndIndex - \cf3 1\cf0 ;\
        \cf7 cout\cf0 <<\cf8 "Pivot = "\cf0 <<PivotPosition<<\cf8 " greater than pivot = "\cf0 <<greaterThanPivot<<\cf8 " less than pivot = "\cf0 <<lessThanPivot<<\cf9 endl\cf0 ;\
        \cf2 while\cf0 (lessThanPivot <= greaterThanPivot)\
        \{\
            \cf2 while\cf0  (a[PivotPosition] > a[lessThanPivot])\
            \{\
                lessThanPivot++;\
            \}\
            \cf2 while\cf0  (a[PivotPosition] < a[greaterThanPivot])\
            \{\
                greaterThanPivot--;\
            \}\
            \cf7 cout\cf0 <<\cf8 "Pivot = "\cf0 <<PivotPosition<<\cf8 " greater than pivot = "\cf0 <<greaterThanPivot<<\cf8 " less than pivot = "\cf0 <<lessThanPivot<<\cf9 endl\cf0 ;\
            \cf4 //The condition lessThanPivot <= greaterThanPivot is very important coz the left side is taken care by the lessThanPivot pointer and the right side is taken care by the greaterThanPivot pointer if they both cross that is if lessThanPivot pointer goes to left side then they again jumble up the array\cf0 \
            \cf2 if\cf0 (lessThanPivot <= greaterThanPivot)\
            \{\
                \cf5 swap\cf0 (a[greaterThanPivot], a[lessThanPivot]);\
                lessThanPivot++;\
                greaterThanPivot--;\
            \}\
        \}\
        \cf4 //Finally put pivot in its right position by swapping it with less thanPivot Pointer\cf0 \
        \cf7 cout\cf0 <<\cf8 "Swapping "\cf0 <<a[PivotPosition]<<\cf8 " with "\cf0 <<a[lessThanPivot]<<\cf9 endl\cf0 ;\
        \cf5 swap\cf0 (a[PivotPosition] , a[lessThanPivot]);\
        \cf4 //for recurrssion the 2 halves are StartIndex to PivotPosition - 1 and from PivotPosition + 1 to EndIndex\cf0 \
        \cf5 printArray\cf0 (a);\
        \cf2 return\cf0  PivotPosition;\
    \}\
    \cf2 return\cf0  -\cf3 1\cf0 ;\
\}\
\
\cf2 void\cf0  QuickSort(\cf2 int\cf0  a[], \cf2 int\cf0  StartIndex, \cf2 int\cf0  EndIndex)\
\{\
    \cf2 if\cf0 (StartIndex <= EndIndex)\
    \{\
        \cf2 int\cf0  PartitionIndex = \cf5 partition\cf0 (a, StartIndex, EndIndex);\
        \cf2 if\cf0 (PartitionIndex != -\cf3 1\cf0 )\
        \{\
            \cf5 QuickSort\cf0 (a, StartIndex, PartitionIndex-\cf3 1\cf0 );\
            \cf5 QuickSort\cf0 (a, PartitionIndex+\cf3 1\cf0 , EndIndex);\
        \}\
    \}\
\}\
\
\cf2 int\cf0  main()\
\{\
    \cf2 int\cf0  a[\cf6 size\cf0 ] = \{\cf3 7\cf0 ,\cf3 2\cf0 ,\cf3 1\cf0 ,\cf3 6\cf0 ,\cf3 8\cf0 ,\cf3 5\cf0 ,\cf3 3\cf0 ,\cf3 4\cf0 \};\
    \cf5 QuickSort\cf0 (a, \cf3 0\cf0 , \cf6 size\cf0 -\cf3 1\cf0 );\
    \cf5 printArray\cf0 (a);\
\}\
\
=================================================================================\
\
\cf2 const\cf0  \cf2 static\cf0  \cf2 int\cf0  size = \cf3 8\cf0 ;\
\
\cf2 void\cf0  swap(\cf2 int\cf0  &a, \cf2 int\cf0  &b)\
\{\
    \cf2 int\cf0  temp = a;\
    a = b;\
    b = temp;\
\}\
\
\cf2 void\cf0  printArray(\cf2 int\cf0  a[])\
\{\
    \cf2 for\cf0 (\cf2 int\cf0  i = \cf3 0\cf0 ; i < \cf6 size\cf0 ; i++)\
    \{\
        \cf7 cout\cf0 <<a[i]<<\cf8 " "\cf0 ;\
    \}\
    \cf7 cout\cf0 <<\cf9 endl\cf0 ;\
\}\
\
\cf2 int\cf0  partition(\cf2 int\cf0  a[], \cf2 int\cf0  StartIndex, \cf2 int\cf0  EndIndex)\
\{\
    \cf2 if\cf0 (StartIndex <= EndIndex)\
    \{\
        \cf2 int\cf0  Pivot = a[EndIndex];\
        \cf2 int\cf0  PartitionIndex = StartIndex;\
        \cf2 for\cf0 (\cf2 int\cf0  i = StartIndex; i < EndIndex; i++)\
        \{\
            \cf2 if\cf0 (a[i] <= Pivot)\
            \{\
                \cf5 swap\cf0 (a[i], a[PartitionIndex]);\
                PartitionIndex++;\
            \}\
        \}\
        \cf5 swap\cf0 (a[PartitionIndex], a[EndIndex]);\
        \cf2 return\cf0  PartitionIndex;\
    \}\
    \cf2 else\cf0 \
    \{\
        \cf2 return\cf0  -\cf3 1\cf0 ;\
    \}\
\}\
\
\cf2 void\cf0  QuickSort(\cf2 int\cf0  a[], \cf2 int\cf0  StartIndex, \cf2 int\cf0  EndIndex)\
\{\
    \cf2 if\cf0 (StartIndex < EndIndex)\
    \{\
        \cf2 int\cf0  PartitionIndex = \cf5 partition\cf0 (a, StartIndex, EndIndex);\
        \cf2 if\cf0 (PartitionIndex != -\cf3 1\cf0 )\
        \{\
            \cf5 QuickSort\cf0 (a, StartIndex, PartitionIndex- \cf3 1\cf0 );\
            \cf5 QuickSort\cf0 (a, PartitionIndex + \cf3 1\cf0 , EndIndex);\
        \}\
    \}\
\}\
\
\cf2 int\cf0  main()\
\{\
    \cf2 int\cf0  a[\cf6 size\cf0 ] = \{\cf3 7\cf0 ,\cf3 2\cf0 ,\cf3 1\cf0 ,\cf3 6\cf0 ,\cf3 8\cf0 ,\cf3 5\cf0 ,\cf3 3\cf0 ,\cf3 4\cf0 \};\
    \cf5 QuickSort\cf0 (a, \cf3 0\cf0 , \cf6 size\cf0 -\cf3 1\cf0 );\
    \cf5 printArray\cf0 (a);\
\}}