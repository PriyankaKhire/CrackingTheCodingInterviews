{\rtf1\ansi\ansicpg1252\cocoartf1348\cocoasubrtf170
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red170\green13\blue145;\red63\green110\blue116;\red92\green38\blue153;
\red28\green0\blue207;\red38\green71\blue75;\red0\green116\blue0;\red196\green26\blue22;\red46\green13\blue110;
}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab529
\pard\tx529\pardeftab529\pardirnatural

\f0\fs22 \cf2 \CocoaLigature0 struct\cf0  LinkedList\
\{\
    \cf2 int\cf0  data;\
    \cf3 LinkedList\cf0  *link;\
\};\
\
\cf3 LinkedList\cf0  *RootNode = \cf2 new\cf0  \cf3 LinkedList\cf0 ;\
\cf4 map\cf0 <\cf2 int\cf0 , \cf2 bool\cf0 > mymap;\
\
\cf3 LinkedList\cf0  *CreateNode(\cf2 int\cf0  data)\
\{\
    \cf3 LinkedList\cf0  *NewNode = \cf2 new\cf0  \cf3 LinkedList\cf0 ;\
    NewNode->\cf3 data\cf0  = data;\
    NewNode->\cf3 link\cf0  = \cf2 NULL\cf0 ;\
    \cf2 return\cf0  NewNode;\
\}\
\
\cf2 void\cf0  insert(\cf2 int\cf0  data)\
\{\
    \cf2 if\cf0 (\cf3 RootNode\cf0 ->\cf3 data\cf0  == \cf5 0\cf0 )\
    \{\
        \cf3 RootNode\cf0 ->\cf3 data\cf0  = \cf3 RootNode\cf0 ->\cf3 data\cf0 +\cf5 1\cf0 ;\
        \cf3 LinkedList\cf0  *Node;\
        Node = \cf6 CreateNode\cf0 (data);\
        \cf3 RootNode\cf0 ->\cf3 link\cf0  = Node;\
    \}\
    \cf2 else\cf0 \
    \{\
        \cf3 RootNode\cf0 ->\cf3 data\cf0  = \cf3 RootNode\cf0 ->\cf3 data\cf0  + \cf5 1\cf0 ;\
        \cf3 LinkedList\cf0  *Node;\
        Node = \cf6 CreateNode\cf0 (data);\
        \
        \cf7 //Insert From Front\cf0 \
        \cf2 if\cf0 (\cf3 RootNode\cf0 ->\cf3 data\cf0 %\cf5 2\cf0  == \cf5 0\cf0 )\
        \{\
            Node->\cf3 link\cf0  = \cf3 RootNode\cf0 ->\cf3 link\cf0 ;\
            \cf3 RootNode\cf0 ->\cf3 link\cf0  = Node;\
        \}\
        \cf7 //Insert From back\cf0 \
        \cf2 else\cf0 \
        \{\
            \cf3 LinkedList\cf0  *ptr;\
            ptr = \cf3 RootNode\cf0 ;\
            \cf2 while\cf0 (ptr->\cf3 link\cf0  != \cf2 NULL\cf0 )\
            \{\
                ptr = ptr->\cf3 link\cf0 ;\
            \}\
            ptr->\cf3 link\cf0  = Node;\
        \}\
        \
    \}\
\}\
\
\cf2 void\cf0  display()\
\{\
    \cf3 LinkedList\cf0  *ptr;\
    ptr = \cf3 RootNode\cf0 ;\
    \cf4 cout\cf0 <<\cf8 "\\nDisplay 1 \\n"\cf0 ;\
    \cf2 while\cf0 (ptr->\cf3 link\cf0  != \cf2 NULL\cf0 )\
    \{\
        \cf4 cout\cf0 <<ptr->\cf3 data\cf0 <<\cf8 " "\cf0 ;\
        ptr = ptr ->\cf3 link\cf0 ;\
    \}\
    \cf4 cout\cf0 <<\cf8 "\\nDiplay 2\\n"\cf0 ;\
    ptr = \cf3 RootNode\cf0 ;\
    \cf2 while\cf0 (ptr != \cf2 NULL\cf0 )\
    \{\
        \cf4 cout\cf0 <<ptr->\cf3 data\cf0 <<\cf8 " "\cf0 ;\
        ptr = ptr->\cf3 link\cf0 ;\
    \}\
\}\
\
\cf2 void\cf0  reverse()\
\{\
    \cf7 //If there is just 1 node in linked list\cf0 \
    \cf2 if\cf0 (\cf3 RootNode\cf0 ->\cf3 data\cf0  == \cf5 1\cf0 )\
    \{\
        \cf2 return\cf0 ;\
    \}\
    \cf7 //If there are 2 nodes\cf0 \
    \cf2 else\cf0 \
        \cf2 if\cf0 (\cf3 RootNode\cf0 ->\cf3 data\cf0  == \cf5 2\cf0 )\
        \{\
            \cf3 LinkedList\cf0  *Node;\
            Node = \cf3 RootNode\cf0 ->\cf3 link\cf0 ;\
            Node->\cf3 link\cf0  = \cf3 RootNode\cf0 ;\
            \cf3 RootNode\cf0 ->\cf3 link\cf0  = \cf2 NULL\cf0 ;\
            \cf3 RootNode\cf0  = Node;\
        \}\
    \cf7 //If there are 3 or more nodes\cf0 \
    \cf2 else\cf0 \
    \{\
        \cf3 LinkedList\cf0  *a, *b, *c;\
        a = \cf3 RootNode\cf0 ->\cf3 link\cf0 ;\
        b = \cf3 RootNode\cf0 ->\cf3 link\cf0 ;\
        c = \cf3 RootNode\cf0 ;\
        \cf2 while\cf0 (a->\cf3 link\cf0  != \cf2 NULL\cf0 )\
        \{\
            a = a->\cf3 link\cf0 ;\
            b->\cf3 link\cf0  = c;\
            c = b;\
            b = a;\
        \}\
        a->\cf3 link\cf0  = c;\
        \cf3 RootNode\cf0 ->\cf3 link\cf0  = \cf2 NULL\cf0 ;\
        \cf3 RootNode\cf0  = a;\
    \}\
\}\
\
\cf2 void\cf0  CreateLoop(\cf2 int\cf0  data)\
\{\
    \cf3 LinkedList\cf0  *ptr;\
    ptr = \cf3 RootNode\cf0 ;\
    \cf2 while\cf0 (ptr->\cf3 link\cf0  != \cf2 NULL\cf0 )\
    \{\
        ptr = ptr->\cf3 link\cf0 ;\
    \}\
    \cf3 LinkedList\cf0  *ptr2;\
    ptr2 = \cf3 RootNode\cf0 ;\
    \cf2 while\cf0  (ptr2->\cf3 data\cf0  != data)\
    \{\
        ptr2 = ptr2->\cf3 link\cf0 ;\
    \}\
    ptr->\cf3 link\cf0  = ptr2;\
\}\
\
\cf2 void\cf0  LoopDetection()\
\{\
    \cf3 LinkedList\cf0  *Rabbit;\
    \cf3 LinkedList\cf0  *Tortoise;\
    Rabbit = \cf3 RootNode\cf0 ;\
    Tortoise = \cf3 RootNode\cf0 ;\
    \
    \cf2 while\cf0 (Rabbit->\cf3 link\cf0  != \cf2 NULL\cf0 )\
    \{\
        Rabbit = Rabbit->\cf3 link\cf0 ;\
        \cf2 if\cf0 (Rabbit != \cf2 NULL\cf0 )\
        \{\
            Rabbit = Rabbit->\cf3 link\cf0 ;\
            Tortoise = Tortoise->\cf3 link\cf0 ;\
        \}\
        \cf2 if\cf0 (Rabbit == Tortoise)\
        \{\
            \cf4 cout\cf0 <<\cf8 "\\nLoop Detected at "\cf0 <<Tortoise->\cf3 data\cf0 ;\
            \cf2 break\cf0 ;\
        \}\
    \}\
    \cf4 cout\cf0 <<\cf9 endl\cf0 <<Rabbit->\cf3 data\cf0 <<\cf9 endl\cf0 <<Tortoise->\cf3 data\cf0 ;\
\}\
\
\cf2 void\cf0  RemoveDuplicates()\
\{\
    \
    \cf2 if\cf0 (\cf3 RootNode\cf0 ->\cf3 data\cf0  == \cf5 1\cf0 )\
    \{\
        \cf2 return\cf0 ;\
    \}\
    \cf2 else\cf0 \
    \{\
        \
        \cf3 LinkedList\cf0  *Curr, *Prev;\
        Curr = \cf3 RootNode\cf0 ;\
        Prev = \cf3 RootNode\cf0 ;\
        \cf2 while\cf0 (Curr != \cf2 NULL\cf0 )\
        \{\
            \cf2 if\cf0 (\cf3 mymap\cf0 [\cf9 Curr\cf0 ->\cf9 data\cf0 ] == \cf5 0\cf0 )\
            \{\
                \cf3 mymap\cf0 [\cf9 Curr\cf0 ->\cf9 data\cf0 ] = \cf2 true\cf0 ;\
                Prev = Curr;\
                Curr = Curr->\cf3 link\cf0 ;\
            \}\
            \cf2 else\cf0 \
            \{\
                Prev->\cf3 link\cf0  = Curr->\cf3 link\cf0 ;\
                \cf9 free\cf0 (Curr);\
                Curr = Prev->\cf3 link\cf0 ;\
            \}\
        \}\
    \}\
\}\
\
\cf2 void\cf0  PartitionLinkedList(\cf2 int\cf0  x)\
\{\
    \cf2 if\cf0 (\cf3 RootNode\cf0 ->\cf3 data\cf0  == \cf5 1\cf0 )\
    \{\
        \cf2 return\cf0 ;\
    \}\
    \cf2 else\cf0 \
    \{\
        \
    \}\
\}\
\
\cf2 int\cf0  main()\
\{\
    \cf3 RootNode\cf0 ->\cf3 data\cf0  = \cf5 1\cf0 ;\
    \cf3 RootNode\cf0 ->\cf3 link\cf0  = \cf2 NULL\cf0 ;\
    \cf7 //RootNode Contains number of nodes attached\cf0 \
    \cf6 insert\cf0 (\cf5 1\cf0 );\
    \cf6 insert\cf0 (\cf5 3\cf0 );\
    \cf6 insert\cf0 (\cf5 2\cf0 );\
    \cf6 insert\cf0 (\cf5 3\cf0 );\
    \cf6 insert\cf0 (\cf5 4\cf0 );\
    \cf6 insert\cf0 (\cf5 2\cf0 );\
    \cf6 insert\cf0 (\cf5 4\cf0 );\
    \cf6 insert\cf0 (\cf5 1\cf0 );\
    \cf6 display\cf0 ();\
    \cf7 //CreateLoop(9);\cf0 \
    \cf7 //LoopDetection();\cf0 \
    \
    \
    \cf2 int\cf0  count = \cf5 7\cf0 ;\
    \cf3 LinkedList\cf0  *ptr;\
    ptr = \cf3 RootNode\cf0 ;\
    \cf2 while\cf0 (count > \cf5 0\cf0  && ptr != \cf2 NULL\cf0 )\
    \{\
        \cf7 //cout<<count;\cf0 \
        count --;\
        ptr = ptr->\cf3 link\cf0 ;\
    \}\
    \cf2 if\cf0 (ptr != \cf2 NULL\cf0 )\
    \{\
        \cf4 cout\cf0 <<\cf8 "\\nCounting "\cf0 <<ptr->\cf3 data\cf0 <<\cf9 endl\cf0 ;\
    \}\
     \
    \
    \cf6 RemoveDuplicates\cf0 ();\
    \cf6 display\cf0 ();\
    \cf6 reverse\cf0 ();\
    \cf6 display\cf0 ();\
    \
    \
\}}