{\rtf1\ansi\ansicpg1252\cocoartf1187\cocoasubrtf400
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red0\green116\blue0;\red170\green13\blue145;\red63\green110\blue116;
\red28\green0\blue207;\red92\green38\blue153;\red46\green13\blue110;\red196\green26\blue22;\red38\green71\blue75;
}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab529
\pard\tx529\pardeftab529\pardirnatural

\f0\fs22 \cf0 \CocoaLigature0 \
\cf2 /* Imagine a (literal) stack of plates. If the stack gets too high, it migh t topple. Therefore, in real life, we would likely start a new stack when the previous stack exceeds some threshold. Implement a data structure SetOfStacks that mimics this. SetOf- Stacks shouldbecomposedofseveralstacksandshouldcreateanewstackonce the previous one exceeds capacity. SetOfStacks.push() and SetOfStacks. pop()shouldbehaveidenticallytoasinglestack(thatis,pop()shouldreturnthe same values asit would if there werejust a single stack).\
 */\cf0 \
\
\cf3 struct\cf0  Node\
\{\
    \cf3 int\cf0  data;\
    \cf4 Node\cf0  *link;\
\};\
\
\cf3 int\cf0  threshhold = \cf5 5\cf0 ;\
\cf3 int\cf0  currentThreshhold = \cf5 0\cf0 ;\
\cf3 int\cf0  CurrentStack = \cf5 0\cf0 ;\
\cf6 vector\cf0 <\cf4 Node\cf0  *>MyVector;\
\
\
\cf3 void\cf0  push(\cf3 int\cf0  data)\
\{\
    \cf3 if\cf0 (\cf4 currentThreshhold\cf0  == \cf4 threshhold\cf0 )\
    \{\
        \cf4 currentThreshhold\cf0  = \cf5 0\cf0 ;\
        \cf4 CurrentStack\cf0 ++;\
        \cf4 MyVector\cf0 .\cf7 push_back\cf0 (\cf3 NULL\cf0 );\
        \cf4 Node\cf0  *NewNode = \cf3 new\cf0  \cf4 Node\cf0 ;\
        NewNode->\cf4 data\cf0  = data;\
        NewNode->\cf4 link\cf0  = \cf3 NULL\cf0 ;\
        \cf4 MyVector\cf0 [\cf7 CurrentStack\cf0 ] = NewNode;\
        \cf4 currentThreshhold\cf0 ++;\
    \}\
    \cf3 else\cf0 \
    \{\
        \cf2 //If first Node\cf0 \
        \cf3 if\cf0 (\cf4 MyVector\cf0 [\cf7 CurrentStack\cf0 ] == \cf3 NULL\cf0 )\
        \{\
            \cf4 Node\cf0  *NewNode = \cf3 new\cf0  \cf4 Node\cf0 ;\
            NewNode->\cf4 data\cf0  = data;\
            NewNode->\cf4 link\cf0  = \cf3 NULL\cf0 ;\
            \cf4 MyVector\cf0 [\cf7 CurrentStack\cf0 ] = NewNode;\
            \cf4 currentThreshhold\cf0 ++;\
        \}\
        \cf3 else\cf0 \
        \{\
            \cf4 Node\cf0  *NewNode = \cf3 new\cf0  \cf4 Node\cf0 ;\
            NewNode->\cf4 data\cf0  = data;\
            NewNode->\cf4 link\cf0  = \cf4 MyVector\cf0 [\cf7 CurrentStack\cf0 ];\
            \cf4 MyVector\cf0 [\cf7 CurrentStack\cf0 ] = NewNode;\
            \cf4 currentThreshhold\cf0 ++;\
        \}\
        \
    \}\
\}\
\
\
\
\cf3 void\cf0  disp()\
\{\
    \cf3 for\cf0 (\cf3 int\cf0  i = \cf5 0\cf0 ; i<\cf4 CurrentStack\cf0 +\cf5 1\cf0 ; i++)\
    \{\
        \cf6 cout\cf0 <<\cf8 "Stack "\cf0 <<i<<\cf7 endl\cf0 ;\
        \cf4 Node\cf0  *ptr = \cf4 MyVector\cf0 [\cf7 i\cf0 ];\
        \cf3 while\cf0 (ptr != \cf3 NULL\cf0 )\
        \{\
            \cf6 cout\cf0 <<ptr->\cf4 data\cf0 <<\cf7 endl\cf0 ;\
            ptr = ptr->\cf4 link\cf0 ;\
        \}\
    \}\
\}\
\
\cf3 int\cf0  main()\
\{\
    \cf2 //Push Null in first vector\cf0 \
    \cf4 MyVector\cf0 .\cf7 push_back\cf0 (\cf3 NULL\cf0 );\
    \
    \cf9 push\cf0 (\cf5 10\cf0 );\
    \cf9 push\cf0 (\cf5 20\cf0 );\
    \cf9 push\cf0 (\cf5 30\cf0 );\
    \cf9 push\cf0 (\cf5 40\cf0 );\
    \cf9 push\cf0 (\cf5 50\cf0 );\
    \cf9 push\cf0 (\cf5 1\cf0 );\
    \cf9 push\cf0 (\cf5 2\cf0 );\
    \cf9 push\cf0 (\cf5 3\cf0 );\
    \cf9 push\cf0 (\cf5 4\cf0 );\
    \cf9 push\cf0 (\cf5 5\cf0 );\
    \cf9 disp\cf0 ();\
    \
    \
\}\
}