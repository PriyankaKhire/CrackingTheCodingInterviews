{\rtf1\ansi\ansicpg1252\cocoartf1187\cocoasubrtf400
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;\f1\fswiss\fcharset0 Helvetica;\f2\froman\fcharset0 Times-Roman;
}
{\colortbl;\red255\green255\blue255;\red92\green38\blue153;\red63\green110\blue116;\red170\green13\blue145;
\red46\green13\blue110;\red196\green26\blue22;\red28\green0\blue207;\red38\green71\blue75;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{none\}.}{\leveltext\leveltemplateid1\'01.;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab529
\pard\tx529\pardeftab529\pardirnatural

\f0\fs22 \cf2 \CocoaLigature0 /*\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa240
\ls1\ilvl0
\f1\fs26 \cf0 \CocoaLigature1 {\listtext	.	}Given a binary tree, design an 
\fs30 algorithm which 
\fs26 creates a 
\fs30 linked list 
\fs26 of all the nodes at each depth 
\f2\fs24 \
\pard\tx529\pardeftab529\pardirnatural

\f0\fs22 \cf2 \CocoaLigature0 \
*/\
\
queue\cf0 <\cf3 TreeNode\cf0  *> BFSQueue;\
\cf2 queue\cf0 <\cf4 int\cf0 > bfsq;\
\pard\tx529\pardeftab529\pardirnatural
\cf4 void\cf0  DLinkedList()\
\{\
    \cf4 if\cf0 (!\cf3 BFSQueue\cf0 .\cf5 empty\cf0 ())\
    \{\
        \cf3 TreeNode\cf0  *top = \cf3 BFSQueue\cf0 .\cf5 front\cf0 ();\
        \cf4 int\cf0  t = \cf3 bfsq\cf0 .\cf5 front\cf0 ();\
        \cf3 bfsq\cf0 .\cf5 pop\cf0 ();\
        \cf3 BFSQueue\cf0 .\cf5 pop\cf0 ();\
        \cf2 cout\cf0 <<t<<\cf6 " "\cf0 <<top->\cf3 data\cf0 <<\cf5 endl\cf0 ;\
        \
        \cf4 if\cf0 (top->\cf3 rlink\cf0  != \cf4 NULL\cf0 )\
        \{\
            \cf3 BFSQueue\cf0 .\cf5 push\cf0 (top->\cf3 rlink\cf0 );\
            \cf3 bfsq\cf0 .\cf5 push\cf0 (t+\cf7 1\cf0 );\
        \}\
        \cf4 if\cf0 (top->\cf3 llink\cf0  != \cf4 NULL\cf0 )\
        \{\
            \cf3 BFSQueue\cf0 .\cf5 push\cf0 (top->\cf3 llink\cf0 );\
            \cf3 bfsq\cf0 .\cf5 push\cf0 (t+\cf7 1\cf0 );\
        \}\
        \cf8 DLinkedList\cf0 ();\
        \
    \}\
\}\
\
==================================================================================================================================================================\
\
//Print the levels\
\
\cf4 void\cf0  inorderLevelPrint(\cf3 TreeNode\cf0  *Node, \cf4 int\cf0  level)\
\{\
    \cf4 if\cf0 (Node != \cf4 NULL\cf0 )\
    \{\
        \cf8 inorderLevelPrint\cf0 (Node->\cf3 llink\cf0 , level+\cf7 1\cf0 );\
        \cf2 cout\cf0 <<Node->\cf3 data\cf0 <<level;\
        \cf8 inorderLevelPrint\cf0 (Node->\cf3 rlink\cf0 , level+\cf7 1\cf0 );\
    \}\
\}\
\
\
//Print the leaves levels\
\
\cf4 void\cf0  inorderLevelPrint(\cf3 TreeNode\cf0  *Node, \cf4 int\cf0  level)\
\{\
    \cf4 if\cf0 (Node != \cf4 NULL\cf0 )\
    \{\
        \cf8 inorderLevelPrint\cf0 (Node->\cf3 llink\cf0 , level+\cf7 1\cf0 );\
        \cf4 if\cf0 (Node->\cf3 llink\cf0  != \cf4 NULL\cf0  && Node->\cf3 rlink\cf0  == \cf4 NULL\cf0 )\
        \{\
            \cf2 cout\cf0 <<Node->\cf3 data\cf0 <<level;\
        \}\
        \cf8 inorderLevelPrint\cf0 (Node->\cf3 rlink\cf0 , level+\cf7 1\cf0 );\
    \}\
\}\
\
//Print only the left leaves\
\
\cf4 void\cf0  inorderLevelPrint(\cf3 TreeNode\cf0  *Node, \cf4 int\cf0  level, \cf4 char\cf0  LR)\
\{\
    \cf4 if\cf0 (Node != \cf4 NULL\cf0 )\
    \{\
        \cf8 inorderLevelPrint\cf0 (Node->\cf3 llink\cf0 , level+\cf7 1\cf0 , \cf7 'L'\cf0 );\
        \cf4 if\cf0 (Node->\cf3 llink\cf0  != \cf4 NULL\cf0  && Node->\cf3 rlink\cf0  == \cf4 NULL\cf0  && LR == \cf7 'L'\cf0 )\
        \{\
            \cf2 cout\cf0 <<Node->\cf3 data\cf0 <<level;\
        \}\
        \cf8 inorderLevelPrint\cf0 (Node->\cf3 rlink\cf0 , level+\cf7 1\cf0 , \cf7 'R'\cf0 );\
    \}\
\}}