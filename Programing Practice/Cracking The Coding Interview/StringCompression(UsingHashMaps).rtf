{\rtf1\ansi\ansicpg1252\cocoartf1187\cocoasubrtf400
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red0\green116\blue0;\red170\green13\blue145;\red92\green38\blue153;
\red196\green26\blue22;\red28\green0\blue207;\red46\green13\blue110;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab529
\pard\tx529\pardeftab529\pardirnatural

\f0\fs22 \cf2 \CocoaLigature0 /*\
Implement a method to perform basic string compression using the counts of repeated characters. For example, the string aabcccccaaa would become a2blc5a3. If the "compressed" string would not become smaller than the orig- inal string, your method should return the original string.\
 */\cf0 \
\
\
\cf3 int\cf0  main()\
\{\
    \cf4 string\cf0  Str1 = \cf5 "aabcccccaaa"\cf0 ;\
    \cf4 map\cf0 <\cf3 int\cf0 , \cf3 int\cf0 >HashMap;\
    \cf4 map\cf0 <\cf3 int\cf0 , \cf3 int\cf0 >::\cf4 iterator\cf0  it;\
    \
    \cf3 int\cf0  j = \cf6 0\cf0 ;\
    \cf3 for\cf0 (\cf3 int\cf0  i = \cf6 0\cf0 ; i < Str1.\cf7 length\cf0 (); i++)\
    \{\
        \cf3 if\cf0 (i == j)\
        \{\
            HashMap[\cf7 j\cf0 ] = \cf6 1\cf0 ;\
        \}\
        \cf3 else\cf0 \
        \{\
            \cf3 if\cf0 (Str1[\cf7 i\cf0 ] == Str1[\cf7 j\cf0 ])\
            \{\
                HashMap[\cf7 j\cf0 ] = HashMap[\cf7 j\cf0 ]+\cf6 1\cf0 ;\
            \}\
            \cf3 else\cf0 \
            \{\
                j = i;\
                HashMap[\cf7 j\cf0 ] = \cf6 1\cf0 ;\
            \}\
        \}\
    \}\
\
    j = \cf6 0\cf0 ;\
    \cf3 bool\cf0  oneFlag = \cf3 true\cf0 ;\
    \cf3 for\cf0 (\cf3 int\cf0  i = \cf6 0\cf0 ; i < Str1.\cf7 length\cf0 (); i ++)\
    \{\
        \cf3 if\cf0 (HashMap[\cf7 i\cf0 ] >\cf6 1\cf0 )\
        \{\
            oneFlag = \cf3 false\cf0 ;\
        \}\
        \cf3 if\cf0 (HashMap[\cf7 i\cf0 ] > \cf6 0\cf0 )\
        \{\
            \cf4 cout\cf0 <<Str1[\cf7 i\cf0 ];\
            \cf4 cout\cf0 <<HashMap[\cf7 i\cf0 ];\
        \}\
    \}\
    \
    \cf3 if\cf0 (oneFlag == \cf3 true\cf0 )\
    \{\
        \cf4 cout\cf0 <<\cf7 endl\cf0 <<Str1<<\cf7 endl\cf0 ;\
    \}\
    \
    \cf2 //Without using hash maps\cf0 \
    \cf3 char\cf0  Answer[Str1.\cf7 length\cf0 ()];\
    \cf3 int\cf0  Ans[Str1.\cf7 length\cf0 ()];\
    oneFlag = \cf3 true\cf0 ;\
    j = \cf6 0\cf0 ;\
    \cf3 for\cf0 (\cf3 int\cf0  i = \cf6 0\cf0 ; i < Str1.\cf7 length\cf0 (); i++)\
    \{\
        \cf3 if\cf0 ( i == j)\
        \{\
            Answer[j] = Str1[\cf7 i\cf0 ];\
            Ans[j] = \cf6 1\cf0 ;\
        \}\
        \cf3 else\cf0 \
        \{\
            \cf3 if\cf0 (Str1[\cf7 i\cf0 ] == Answer[j])\
            \{\
                Ans[j] = Ans[j] + \cf6 1\cf0 ;\
                oneFlag = \cf3 false\cf0 ;\
                \
            \}\
            \cf3 else\cf0 \
            \{\
                j++;\
                Answer[j] = Str1[\cf7 i\cf0 ];\
                Ans[j] = \cf6 1\cf0 ;\
            \}\
        \}\
    \}\
    \cf4 cout\cf0 <<\cf7 endl\cf0 ;\
    \cf3 if\cf0 (oneFlag == \cf3 false\cf0 )\
    \{\
    \cf3 for\cf0 (\cf3 int\cf0  i = \cf6 0\cf0 ; i < Str1.\cf7 length\cf0 (); i++)\
    \{\
        \cf4 cout\cf0 <<Answer[i]<<Ans[i];\
    \}\
    \}\
    \cf3 else\cf0 \
    \{\
        \cf4 cout\cf0 <<Str1;\
    \}\
    \
    \
\}}