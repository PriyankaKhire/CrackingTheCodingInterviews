{\rtf1\ansi\ansicpg1252\cocoartf1187\cocoasubrtf400
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red0\green116\blue0;\red170\green13\blue145;\red63\green110\blue116;
\red28\green0\blue207;\red38\green71\blue75;\red92\green38\blue153;\red46\green13\blue110;\red196\green26\blue22;
}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab529
\pard\tx529\pardeftab529\pardirnatural

\f0\fs22 \cf2 \CocoaLigature0 /*\
Given a sorted (increasing order) array with unique integer elements, write an algorithm to create a binary search tree with minimal height.\
*/\cf0 \
\
\cf3 struct\cf0  TreeNode\
\{\
    \cf3 int\cf0  data;\
    \cf4 TreeNode\cf0  *llink;\
    \cf4 TreeNode\cf0  *rlink;\
\};\
\
\cf4 TreeNode\cf0  *RootNode = \cf3 new\cf0  \cf4 TreeNode\cf0 ;\
\cf3 static\cf0  \cf3 const\cf0  \cf3 int\cf0  size = \cf5 10\cf0 ;\
\cf3 int\cf0  visited[\cf4 size\cf0 ];\
\
\cf3 void\cf0  createBST(\cf3 int\cf0  start, \cf3 int\cf0  end, \cf3 int\cf0  array[\cf4 size\cf0 ], \cf4 TreeNode\cf0  *Node)\
\{\
    \cf3 int\cf0  mid = (end + start)/\cf5 2\cf0 ;\
    \
    \cf3 if\cf0  (Node == \cf3 NULL\cf0  || \cf4 visited\cf0 [mid] == \cf5 1\cf0 )\
    \{\
        \cf3 return\cf0 ;\
    \}\
    \cf3 else\cf0 \
    \{\
    \
    \cf4 TreeNode\cf0  *NewNode = \cf3 new\cf0  \cf4 TreeNode\cf0 ;\
    NewNode->\cf4 data\cf0  = array[mid];\
        \cf4 visited\cf0 [mid] = \cf5 1\cf0 ;\
    NewNode->\cf4 llink\cf0  = NewNode->\cf4 rlink\cf0  = \cf3 NULL\cf0 ;\
    \
    \cf3 if\cf0 (NewNode->\cf4 data\cf0  < Node->\cf4 data\cf0 )\
    \{\
        Node->\cf4 llink\cf0  = NewNode;\
    \}\
    \cf3 else\cf0 \
        Node->\cf4 rlink\cf0  = NewNode;\
    \
    \cf6 createBST\cf0 (start, mid-\cf5 1\cf0 , array, NewNode);\
    \cf6 createBST\cf0 (mid+\cf5 1\cf0 , end, array, NewNode);\
    \}\
\}\
\
\cf3 void\cf0  traversal(\cf4 TreeNode\cf0  *Node)\
\{\
    \cf3 if\cf0 (Node == \cf3 NULL\cf0 )\
    \{\
        \cf3 return\cf0 ;\
    \}\
    \cf3 else\cf0 \
    \{\
        \cf6 traversal\cf0 (Node->\cf4 llink\cf0 );\
        \cf7 cout\cf0 <<Node->\cf4 data\cf0 <<\cf8 endl\cf0 ;\
        \cf6 traversal\cf0 (Node->\cf4 rlink\cf0 );\
    \}\
\}\
\
\cf3 int\cf0  main()\
\{\
    \cf3 int\cf0  array[\cf4 size\cf0 ];\
    \
    \cf7 cout\cf0 <<\cf9 "Enter elements of array in sorted order \\n"\cf0 ;\
    \cf3 for\cf0 (\cf3 int\cf0  i = \cf5 0\cf0 ;i <\cf4 size\cf0 ; i++)\
    \{\
        \cf7 cin\cf0 >>array[i];\
    \}\
    \
    \cf3 for\cf0 (\cf3 int\cf0  i = \cf5 0\cf0 ; i<\cf4 size\cf0 ; i++)\
    \{\
        \cf4 visited\cf0 [i] = \cf5 0\cf0 ;\
    \}\
    \
    \cf2 // Make the root node\cf0 \
    \cf3 int\cf0  mid = \cf4 size\cf0 /\cf5 2\cf0 ;\
    \cf4 RootNode\cf0 ->\cf4 data\cf0  = array[mid];\
    \cf4 visited\cf0 [mid] = \cf5 1\cf0 ;\
    \cf4 RootNode\cf0 ->\cf4 llink\cf0  = \cf4 RootNode\cf0 ->\cf4 rlink\cf0  = \cf3 NULL\cf0 ;\
    \
    \cf6 createBST\cf0 (\cf5 0\cf0 , mid-\cf5 1\cf0 , array, \cf4 RootNode\cf0 );\
    \cf6 createBST\cf0 (mid+\cf5 1\cf0 , \cf4 size\cf0 , array, \cf4 RootNode\cf0 );\
    \
    \
    \cf6 traversal\cf0 (\cf4 RootNode\cf0 );\
    \
\}}